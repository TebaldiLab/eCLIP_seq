---
title: "AGO2_clip_analysis"
output:
  word_document: default
  html_notebook: default
  pdf_document: default
---

<style>
body {
text-align: justify}
</style>


```{r setup_data, message=F,warning=F,echo=F}

# Load necessary libraries
library(tidyverse)
library(ggrepel)
library(ggbeeswarm)
library(ggthemes)
library(ggseqlogo)
library(data.table)

library(GenomicRanges) # deal with genomic intervals (e.g. bed files)

library(BSgenome) # genome functions
#library(BSgenome.Hsapiens.UCSC.hg38) # human genome
library(BSgenome.Mmusculus.UCSC.mm10) # mouse genome

library(Biostrings) # deals with sequences (e.g. fasta files)
library(GenomicAlignments) # deals with genomic alignments (e.g. bam files)

library(edgeR) # differential analysis

library("extrafont")
loadfonts(quiet=T)
bs<-11
bf<-"Arial"

# Load necessary raw and processed data
load("./data/mm92_anno.RData") 
load("./data/counts_raw_dt.RData") 

A_color<-"#0f9648"
C_color<-"#255c99"
G_color<-"#f7b32b"
U_color<-"#d62839"

```

# Collect coverage for each peak in each CLIP and INPUT replicate

```{r, message=F,warning=F,echo=F, eval=F}

resume_bedcoverage<-function(dir, # directory with the bed files
                             name_cols=c(1,2,3,6), # numeric or vector: columns with feature names
                             cov_col=7   # numeric: column with coverage values
) {
  
  list_input<-fs::dir_ls(dir,glob="*.bed",type="file")
  
  if(exists("o_tab")){
    rm(o_tab)
  }
  
  for(i in (list_input)){
    
    i_tab<-as.data.table(read_tsv(i,col_names=F, progress = F,show_col_types = F))
    
    s_name<-str_split(i,dir,simplify=T)[,2] 
    s_name<-str_split(s_name,"\\.",simplify=T)[,1]
    
    x_tab <- i_tab[, .(id=do.call(paste, c(.SD, sep="_"))), .SDcols= name_cols]
    x_tab[,(s_name):= i_tab[[cov_col]]]
    
    rm(i_tab)
    
    if(!exists("o_tab")){
      o_tab<- x_tab
    } else {
      o_tab<- merge(o_tab,x_tab,by="id",all = T)
    }
  }
  return(o_tab)
}


counts_raw_dt<-resume_bedcoverage(dir="./data/coverage_beds/",
                            name_cols=c(1,2,3,6), # numeric or vector: columns with feature names
                            cov_col=8   # numeric: column with coverage values
)

```

# Sample annotation

```{r c_anno, message=F,warning=F, echo=F}

c_anno<-data.table("sample"=colnames(counts_raw_dt[,-"id"]))

c_anno_add <- c_anno[, c("condition","replicate") := tstrsplit(sample,"_",fixed=T)][,-"sample"]

c_anno<-cbind(c_anno,c_anno_add)

c_anno[,condition:=factor(condition, levels=c("ago2","input"))]
c_anno[order(condition,replicate)] 

vec <- c("id",c_anno$sample)
counts_raw_dt<-counts_raw_dt[,..vec]

```

# Filter counts 

```{r filter, message=F,warning=F, echo=F}

sig_thr<-5 #count threshold

counts_long_dt<-counts_raw_dt[,id:=as.factor(id)]

counts_long_dt<-melt.data.table(counts_long_dt, id.vars = c("id"),variable.name = "sample",value.name = "counts")

setkey(counts_long_dt, sample)
setkey(c_anno, sample)
counts_long_dt<-counts_long_dt[c_anno, on = "sample"]

counts_filter_dt <- counts_long_dt[,.(min_c = min(counts)), .(id,condition)][condition=="ago2"]

counts_filter_dt<-counts_filter_dt[, .(passes_c = sum(min_c >= sig_thr)), .(id)]

filter_id <- as.character(counts_filter_dt[passes_c > 0]$id)

counts_dt<-counts_raw_dt[id %in% filter_id]

```

# Create peak annotation

```{r, message=F,warning=F, echo=F}

r_anno<-data.table("id"=counts_dt$id)

r_anno <- r_anno[, c("chr","start","end","strand") := tstrsplit(id,"_",fixed=T)][,-"id"]

r_anno[,start:=as.numeric(start)]
r_anno[,end:=as.numeric(end)]

r_anno[,start_n:=start+10]
r_anno[,end_n:=end-10]

chr_conversion_canonical <- data.table(
   "chr_ens"=c("1","2","3","4","5","6","7","8","9","10",
      "11","12","13","14","15","16","17","18","19","20",
      "21","22","X","Y","MT"),
   "chr_ucsc"=c("chr1","chr2","chr3","chr4","chr5","chr6","chr7","chr8","chr9","chr10",
      "chr11","chr12","chr13","chr14","chr15","chr16","chr17","chr18","chr19","chr20",
      "chr21","chr22","chrX","chrY","chrM"))  

r_anno<-r_anno[chr %in% chr_conversion_canonical$chr_ucsc][end-start==21]

peak_granges<-makeGRangesFromDataFrame(r_anno,
                         keep.extra.columns=F,
                         ignore.strand=F,
                         seqinfo=NULL,
                         seqnames.field="chr",
                         start.field="start",
                         end.field="end",
                         strand.field="strand",
                         starts.in.df.are.0based=T)

r_anno[,peak_seq := str_replace_all(as.character(getSeq(BSgenome.Mmusculus.UCSC.mm10,peak_granges)),"T","U")]

r_anno <- r_anno[!(str_detect(r_anno$peak_seq,"N")),] 

peak_granges<-makeGRangesFromDataFrame(r_anno,
                         keep.extra.columns=F,
                         ignore.strand=F,
                         seqinfo=NULL,
                         seqnames.field="chr",
                         start.field="start",
                         end.field="end",
                         strand.field="strand",
                         starts.in.df.are.0based=T)

nuc_granges<-makeGRangesFromDataFrame(r_anno,
                         keep.extra.columns=F,
                         ignore.strand=F,
                         seqinfo=NULL,
                         seqnames.field="chr",
                         start.field="start_n",
                         end.field="end_n",
                         strand.field="strand",
                         starts.in.df.are.0based=T)


r_anno[,CL_seq := str_replace_all(as.character(getSeq(BSgenome.Mmusculus.UCSC.mm10,nuc_granges)),"T","U")]

# Annotation (intergenic, intronic, exonic)

ense_granges<-makeGRangesFromDataFrame(ense_df,
                         keep.extra.columns=T,
                         ignore.strand=F,
                         seqinfo=NULL,
                         seqnames.field="chr_ucsc",
                         start.field="exon_chrom_start",
                         end.field="exon_chrom_end",
                         strand.field="strand_ucsc",
                         starts.in.df.are.0based=F)


ensg_granges<-makeGRangesFromDataFrame(ensg_df,
                         keep.extra.columns=T,
                         ignore.strand=F,
                         seqinfo=NULL,
                         seqnames.field="chr_ucsc",
                         start.field="start_position",
                         end.field="end_position",
                         strand.field="strand_ucsc",
                         starts.in.df.are.0based=F)


r_anno[,region_class:="intergenic"]

over_genes<- GenomicRanges::findOverlaps(peak_granges, ensg_granges)
peak_genes <- peak_granges[queryHits(over_genes)] 
exon_genes<- peak_granges[subjectHits(over_genes)] 

r_anno[unique(queryHits(over_genes)),"region_class"]<-"intron"

over_exons<- GenomicRanges::findOverlaps(peak_granges, ense_granges)
peak_exons <- peak_granges[queryHits(over_exons)] 
exon_exons<- ense_granges[subjectHits(over_exons)] 

r_anno[unique(queryHits(over_exons)),"region_class"]<-"exon"

r_anno[,region_class:=factor(region_class,levels=c("exon","intron","intergenic"))]
r_anno[,id:=paste(chr,start,end,strand,sep="_")]
counts_dt <-counts_dt[id %in% r_anno$id]

```

# Data Exploration
# Raw counts MDS before normalization

```{r mds_counts, fig.height=4, fig.width=4, warning=FALSE, message=F, echo=FALSE}

sample_data<-scale(t(counts_dt[,-"id"])) 
sample_distances <- dist(sample_data, method = "euclidean") 

mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
mds_cmdscale$sample <- rownames(mds_cmdscale)
mds_cmdscale<-as.data.table(mds_cmdscale)

setkey(mds_cmdscale, sample)
mds_cmdscale<-mds_cmdscale[c_anno, on = "sample"]

cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
  geom_point(size=2.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
  geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
  #scale_colour_manual(values=col_vector) +
  theme_bw(base_size = bs, base_family = bf) + 
  theme(legend.position = "none", panel.grid.minor=element_blank())

cmd

#ggsave("./figures/counts_cmdscale.pdf", cmd, device=cairo_pdf,width = 3.5, height = 3.5, units = c("in"))

```

# Number of reads for each sample

```{r,fig.height=3, fig.width=5, warning=F, message=F,echo=F}

bar_dt<-data.table("sample"=colnames(counts_dt[,-"id"]),"count"=(colSums(counts_dt[,-"id"])/1000000))

setkey(bar_dt, sample)
bar_dt<-bar_dt[c_anno, on = "sample"]


bp<-ggplot(bar_dt,aes(sample,count,fill=condition)) +
  geom_bar(stat="identity",width=0.7) +
  coord_flip() +
  theme_bw(base_size = bs, base_family = bf) +
  theme(axis.title.y=element_blank(),panel.border=element_blank(),axis.text.y = element_text(size=8, colour = "black")) +
  theme(panel.grid.major.y = element_blank(),panel.grid.minor.x = element_blank())+
  theme(legend.position = "na")+
   #scale_fill_manual(values=col_vector)+
  labs(y = "aligned reads (mln)") 
 
bp

#ggsave("./figures/Barplot_counts_nodup.pdf",bp,device=cairo_pdf,width = 3.5, height = 5, units = c("in"))

```

# Selection of CLIP specific peaks by differential expression analysis (edgeR)
# Create and normalize edgeR count object    

```{r edgeR, message=F,warning=F,echo=F}

counts_df<-as.data.frame(counts_dt)
rownames(counts_df)<-counts_df$id
counts_df$id<-NULL

edge_c <- DGEList(counts=counts_df,group=c_anno$condition,samples=c_anno,genes=r_anno) 
edge_n <- calcNormFactors(edge_c,method="TMM") 
norm_factors<-(edge_n$samples$lib.size*edge_n$samples$norm.factors)/mean(edge_n$samples$lib.size*edge_n$samples$norm.factors) 
names(norm_factors)<-edge_n$samples$sample

#norm_factors
norm_dt<-data.table("sample"=names(norm_factors),
                    "div_norm"=norm_factors)

```

# Create count per million (CPM) table

```{r cpm_tables, message=F, warning=F, echo=F}

cpm_table<-as.data.frame(cpm(edge_n,log=F))
cpm_table_dt<-as.data.table(cpm_table)[,id:=rownames(cpm_table)]

l_cpm_table<-melt.data.table(cpm_table_dt, id.vars = c("id"),variable.name = "sample",value.name = "cpm")

setkey(l_cpm_table, sample)
l_cpm_table<-l_cpm_table[c_anno, on = "sample"]

cpm_dt<-l_cpm_table[, .(N=.N,avg=mean(cpm),sd=sd(cpm)), .(condition,id)][, se := sd/sqrt(N)]        

```

# Data Exploration
# MDS after normalization, based on CPM values

```{r mds_cpm, fig.height=4, fig.width=4, warning=F, message=F, echo=F}

sample_data<-scale(t(cpm_table)) 
sample_distances <- dist(sample_data, method = "euclidean") 

mds_cmdscale <- as.data.frame(cmdscale(as.matrix(sample_distances)))
colnames(mds_cmdscale) <- c("MDS_1","MDS_2")
mds_cmdscale$sample <- rownames(mds_cmdscale)
mds_cmdscale<-as.data.table(mds_cmdscale)

setkey(mds_cmdscale, sample)
mds_cmdscale<-mds_cmdscale[c_anno, on = "sample"]

cmd<-ggplot(mds_cmdscale, aes(MDS_1, MDS_2, colour=condition)) + #plot according to the new coordinates
  geom_point(size=2.5,alpha=.9) + #colour=factor(df) to choose colour according to the condition
  geom_text_repel(aes(label=sample), size=0.3*bs, fontface = "bold",show.legend = F) + #geom_text_repel to add text within plot
  #scale_colour_manual(values=col_vector) +
  theme_bw(base_size = bs, base_family = bf) + 
  theme(legend.position = "none", panel.grid.minor=element_blank())

cmd

#ggsave("./counts_cmdscale.pdf", cmd, device=cairo_pdf,width = 3.5, height = 3.5, units = c("in"))

```

# Estimating the Dispersion with edgeR

```{r design, message=F,warning=F,echo=F}

design <- model.matrix(~0+group, data=edge_c$samples) #binary matrix to pair replicates (description of the conditions)
colnames(design)<-levels(edge_c$samples$group)

edge_d <- estimateDisp(edge_n,design,robust=T) # robust=TRUE to have a better estimation of the outliers and usually, at low l

edge_f <- glmQLFit(edge_d,design,robust=T) #squeeze of the variance -> estimation of the quasi-likelihood (QL) dispersions around 

```

# Selection of CLIP specific peaks by comparing CLIP vs INPUT samples

```{r, message=F, warning=F, echo=F}

edgeRglmQLF_2022 <- function(glmfit, # object of class DGEGLM
                      contrast_chr, # comparison (string)
                      comp_name="", # include in label column
                      signal_col="CPM", # signal column
                      signal_thr=0.1, # signal threshold
                      fc_col="log2_FC",
                      fc_thr=0.5, # fold change threshold
                      pval_col="p_val", # p-value column
                      pval_thr=0.05) # p-value threshold
                      { 
  
  contro<-makeContrasts(contrasts=contrast_chr,levels=glmfit$design)
  
  degs<-glmQLFTest(glmfit,
                   contrast= contro)$table[,c("logFC","PValue")]
  colnames(degs)<-c("log2_FC","p_val")
  
  degs$id<-rownames(degs)
  degs$comp<-ifelse(comp_name!="",comp_name,contrast_chr)
  degs$p_adj<-p.adjust(degs$p_val, method ="BH")
  
  active_levels<-rownames(contro)[which(contro!=0)]
  active_samples<-which(glmfit$samples$group%in%active_levels)
  cpm_sele<-cpm(glmfit,log=F)[,active_samples]
  
  degs$CPM<-round(rowMeans(cpm_sele),3)

  degs$class<-"="
  degs[which(degs[,signal_col]>=signal_thr & 
             degs[,fc_col]>=fc_thr & 
             degs[,pval_col]<=pval_thr),"class"]<-"+"

  degs[which(degs[,signal_col]>=signal_thr & 
             degs[,fc_col]<=(-fc_thr) & 
             degs[,pval_col]<=pval_thr),"class"]<-"-"
  
  degs<-degs %>% dplyr::select(id,comp,class,log2_FC,p_val,p_adj,CPM)

  return(degs)
}


# extract results

degs_w_df<-NULL
degs_l_df<-NULL

contro_list<-list("ago2_input"="ago2-input")

for(contro_label in names(contro_list)){

degs_u <-edgeRglmQLF_2022(glmfit=edge_f, 
                     contrast_chr=contro_list[[contro_label]], 
                     comp_name=contro_label, 
                     signal_col="CPM", signal_thr=0,
                     fc_col="log2_FC",fc_thr=1,
                     pval_col="p_val", pval_thr=0.05)

degs_l_df<-bind_rows(degs_l_df,degs_u)
rownames(degs_l_df)<-NULL

degs_add<- degs_u %>% dplyr::select("class","log2_FC","p_val","p_adj","CPM")
colnames(degs_add)<-paste(degs_u[1,"comp"],colnames(degs_add),sep="_")
degs_w_df<-bind_cols(degs_w_df,degs_add)

}

degs_w_df <- degs_w_df %>% add_column(id=rownames(degs_w_df),.before=1) 
degs_w_df <- inner_join(r_anno,degs_w_df)
degs_l_df$comp <- factor(degs_l_df$comp,levels=names(contro_list))

#write_tsv(degs_w_df %>% dplyr::rename(external_gene_name=id),path=("./results/GE_DEGs_table.txt"))


```

# Select peaks with eCLIP signal significantly higher than the INPUT

```{r, message=F,warning=F,echo=F}

DEGs_cand<-as.data.table(degs_w_df)[ago2_input_class=="+"]

table(DEGs_cand$ago2_input_class,DEGs_cand$region_class)

```

# Exons annotation 

```{r annotation_integration, message=F,warning=F,echo=F}

degs_granges<-makeGRangesFromDataFrame(DEGs_cand,
                         keep.extra.columns=T,
                         ignore.strand=F,
                         seqinfo=NULL,
                         seqnames.field="chr",
                         start.field="start",
                         end.field="end",
                         strand.field="strand",
                         starts.in.df.are.0based=T)

over_exons<- GenomicRanges::findOverlaps(degs_granges, ense_granges)

degs_exons <- degs_granges[queryHits(over_exons)] %>% as_tibble() %>% 
  dplyr::rename(peak_start=start,peak_end=end,peak_width=width)
exon_exons<- ense_granges[subjectHits(over_exons)] %>% as_tibble() %>% 
  dplyr::rename(exon_start=start,exon_end=end,exon_width=width) %>% select(-seqnames,-strand)

all_exons<-bind_cols(degs_exons,exon_exons)

all_exons<- as.data.table(all_exons)
setkey(all_exons,external_transcript_name,rank,ago2_input_class)

unique(all_exons[gene_biotype=="protein_coding"][,c("external_gene_name","ago2_input_class")])[, .(genes=.N),by=ago2_input_class]
```

# Define transcript region

```{r, warning=F, message=F, echo=F}

coding_exons<-all_exons[gene_biotype=="protein_coding"]
coding_exons$transcript_region<-"non-coding"
coding_exons[which(coding_exons$l_5utr>0),"transcript_region"]<-"5_UTR"
coding_exons[which(coding_exons$l_cds>0),"transcript_region"]<-"CDS"
coding_exons[which(coding_exons$l_3utr>0),"transcript_region"]<-"3_UTR"

setkey(coding_exons,external_gene_name,transcript_region,ago2_input_class)
coding_exons[,c("external_gene_name","transcript_region","ago2_input_class")][,.(genes=.N),by=transcript_region]

names_5<- coding_exons[which(coding_exons$l_5utr>0),"id"] %>% unlist() %>% unique()
names_cds<- coding_exons[which(coding_exons$l_cds>0),"id"] %>% unlist() %>% unique()
names_3<- coding_exons[which(coding_exons$l_3utr>0),"id"] %>% unlist() %>% unique()

DEGs_cand[which(DEGs_cand$id %in% names_5),"region_class"]<-"5`UTR"
DEGs_cand[which(DEGs_cand$id %in% names_cds),"region_class"]<-"CDS"
DEGs_cand[which(DEGs_cand$id %in% names_3),"region_class"]<-"3`UTR"

```

# Number of unique peaks (defined by x-link nucleotide)

```{r, warning=F, message=F, echo=F, fig.width=6,fig.height=4, echo=F}

plot_dt <- DEGs_cand %>% as.data.frame() # %>% filter(region_class!="intergenic")
plot_dt$region_class <- recode_factor(plot_dt$region_class, exon = "non-coding exon")
plot_dt$region_class <- factor(plot_dt$region_class,levels=c("intergenic","intron","non-coding exon","5`UTR","CDS","3`UTR"))


bp<-ggplot(plot_dt,aes(region_class,fill=region_class))+
   geom_bar(width=.8,alpha=.9)+
   theme_tufte(base_family = bf, base_size = bs)+
   #facet_wrap(vars(region_class),ncol=1)+ #scales="free"
   coord_flip()+
   scale_fill_manual(values=rev(c("grey35","grey40","grey50","grey60","grey70","grey75")))+
   theme(legend.position = "none")+
   scale_y_log10(
      name = "Peak count"
      #labels = function(x) paste0(x / 1000, "k")
      )+
   labs(x="")

bp

#ggsave("peaks_number.pdf",bp,device=cairo_pdf,width = 4.5, height = 2.5, units = c("in"))

```

# Sequence analysis: identification of consensus sequences in CLIP  specific peaks

```{r, warning=F, message=F, echo=F, fig.width=6,fig.height=3}

plot_dt <- DEGs_cand #[id_name %in% coding_exons$id_name]

bp<-ggplot(plot_dt,aes(CL_seq,fill=CL_seq))+
   geom_bar(width=.8,alpha=.9)+
   theme_tufte(base_family = bf, base_size = bs)+
   #facet_wrap(vars(ago2_input_class),scales="free",ncol=4)+
   scale_fill_manual(values=c(A_color,C_color,G_color,U_color))+
   theme(legend.position = "none")+
   scale_y_continuous(
      name = "Peak count",
      labels = function(x) paste0(x / 1000, "k"))+
   labs(x="X-linked nt")

bp

#ggsave("xlink_nucleotide.pdf",bp,device=cairo_pdf,width = 3, height = 2.5, units = c("in"))

```

# Sequence logos

```{r, warning=F, message=F, echo=F, fig.width=7,fig.height=3}

g_seqs <- plot_dt [ago2_input_class=="+"]$peak_seq

sele<-ggseqlogo(list("Ago2_logo"= g_seqs), ncol=1) +
   theme_logo(base_size = 0.6*bs, base_family = bf) + 
   theme(axis.text.x = element_blank()) + 
   scale_y_continuous(breaks=seq(0,2,0.05))
sele

#ggsave("Logos_q157r_as_db_SE.pdf",sele,device=cairo_pdf,width = 2.8, height = 1.5 , units = c("in"))

```

